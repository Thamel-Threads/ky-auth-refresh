{"version":3,"sources":["../src/utils.ts","../src/index.ts"],"names":["defaultOptions","mergeOptions","defaults","options","shouldInterceptError","error","instance","cache","createRefreshCall","fn","createRequestQueueHook","_instance","_options","unsetCache","skipInstance","getRetryInstance","resendFailedRequest","requestOptions","url","createAuthRefreshHook","refreshAuthCall","mergedOptions","afterResponseHook","request","response","hookOptions","mockError","refreshing","retryInstance","index_default"],"mappings":"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","file":"index.cjs","sourcesContent":["import { KyInstance, Options } from 'ky';\nimport type { KyAuthRefreshOptions, KyAuthRefreshCache } from './types.js';\n\nexport interface CustomKyRequestConfig extends Options {\n  skipAuthRefresh?: boolean;\n}\n\nexport const defaultOptions: KyAuthRefreshOptions = {\n  statusCodes: [401],\n  pauseInstanceWhileRefreshing: false,\n};\n\n/**\n * Merges two options objects (options overwrites defaults).\n */\nexport function mergeOptions(\n  defaults: KyAuthRefreshOptions,\n  options: KyAuthRefreshOptions\n): KyAuthRefreshOptions {\n  return {\n    ...defaults,\n    ...options,\n  };\n}\n\n/**\n * Returns TRUE: when error.response.status is contained in options.statusCodes\n * Returns FALSE: when error or error.response doesn't exist or options.statusCodes doesn't include response status\n */\nexport function shouldInterceptError(\n  error: any,\n  options: KyAuthRefreshOptions,\n  instance: KyInstance,\n  cache: KyAuthRefreshCache\n): boolean {\n  if (!error) {\n    return false;\n  }\n\n  if (error.request?.skipAuthRefresh) {\n    return false;\n  }\n\n  if (\n    !(\n      options.interceptNetworkError &&\n      !error.response &&\n      error.request?.status === 0\n    ) &&\n    (!error.response ||\n      (options?.shouldRefresh\n        ? !options.shouldRefresh(error)\n        : !options.statusCodes?.includes(parseInt(error.response.status))))\n  ) {\n    return false;\n  }\n\n  // Copy request to response if there's a network error, so request can be modified and used in the retry\n  if (!error.response) {\n    error.response = {\n      request: error.request,\n    };\n  }\n\n  return (\n    !options.pauseInstanceWhileRefreshing ||\n    !cache.skipInstances.includes(instance)\n  );\n}\n\n/**\n * Creates refresh call if it does not exist or returns the existing one.\n */\nexport function createRefreshCall(\n  error: any,\n  fn: (error: any) => Promise<any>,\n  cache: KyAuthRefreshCache\n): Promise<any> {\n  if (!cache.refreshCall) {\n    cache.refreshCall = fn(error);\n    if (typeof cache.refreshCall.then !== 'function') {\n      console.warn(\n        '@thamel-threads/ky-auth-refresh requires `refreshTokenCall` to return a promise.'\n      );\n      return Promise.reject(\n        new Error('refreshTokenCall must return a promise')\n      );\n    }\n  }\n  return cache.refreshCall;\n}\n\n/**\n * Creates request queue hook if it does not exist and returns its id.\n * Note: This function is not used in the current ky implementation as we handle\n * request queuing differently through the afterResponse hook.\n */\nexport function createRequestQueueHook(\n  _instance: KyInstance,\n  cache: KyAuthRefreshCache,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _options: KyAuthRefreshOptions\n): number {\n  if (typeof cache.requestQueueInterceptorId === 'undefined') {\n    // Generate a unique ID for the hook\n    cache.requestQueueInterceptorId = Math.random();\n\n    // In ky, we don't need to modify the instance directly\n    // The request queuing is handled by the afterResponse hook\n  }\n  return cache.requestQueueInterceptorId;\n}\n\n/**\n * Removes request queue hook and unset hook cached values.\n */\nexport function unsetCache(\n  instance: KyInstance,\n  cache: KyAuthRefreshCache\n): void {\n  // In ky, we don't need to remove hooks from the instance\n  // as each instance is immutable and we create new instances\n  cache.requestQueueInterceptorId = undefined;\n  cache.refreshCall = undefined;\n  cache.skipInstances = cache.skipInstances.filter(\n    skipInstance => skipInstance !== instance\n  );\n}\n\n/**\n * Returns instance that's going to be used when requests are retried\n */\nexport function getRetryInstance(\n  instance: KyInstance,\n  options: KyAuthRefreshOptions\n): KyInstance {\n  return options.retryInstance || instance;\n}\n\n/**\n * Resend failed ky request.\n */\nexport function resendFailedRequest(\n  error: any,\n  instance: KyInstance\n): Promise<Response> {\n  // Mark the request to skip auth refresh to avoid infinite loops\n  const requestOptions = {\n    skipAuthRefresh: true,\n  };\n\n  // Extract the URL and options from the original request\n  const url = error.response.request.url;\n  const options = {\n    method: error.response.request.method,\n    headers: error.response.request.headers,\n    body: error.response.request.body,\n    ...requestOptions,\n  };\n\n  return instance(url, options);\n}\n","import { KyInstance } from 'ky';\nimport type { KyAuthRefreshOptions, KyAuthRefreshCache } from './types.js';\nimport {\n  unsetCache,\n  mergeOptions,\n  defaultOptions,\n  getRetryInstance,\n  createRefreshCall,\n  resendFailedRequest,\n  shouldInterceptError,\n  createRequestQueueHook,\n} from './utils.js';\n\nexport type {\n  KyAuthRefreshOptions,\n  KyAuthRefreshRequestConfig,\n} from './types.js';\n\n/**\n * Creates an authentication refresh hook that binds to any error response.\n * If the response status code is one of the options.statusCodes, hook calls the refreshAuthCall\n * which must return a Promise. While refreshAuthCall is running, all the new requests are intercepted and are waiting\n * for the refresh call to resolve. While running the refreshing call, instance provided is marked as a paused instance\n * which indicates the hook to not intercept any responses from it. This is because you'd otherwise need to mark\n * the specific requests you make by yourself in order to make sure it's not intercepted. This behavior can be\n * turned off, but use it with caution as you need to mark the requests with `skipAuthRefresh` flag yourself in order to\n * not run into hooks loop.\n *\n * @param instance - Ky HTTP client instance\n * @param refreshAuthCall - refresh token call which must return a Promise\n * @param options - options for the hook @see defaultOptions\n * @returns new ky instance with auth refresh functionality\n */\nexport function createAuthRefreshHook(\n  instance: KyInstance,\n  refreshAuthCall: (error: any) => Promise<any>,\n  options: KyAuthRefreshOptions = {}\n): KyInstance {\n  if (typeof refreshAuthCall !== 'function') {\n    throw new Error(\n      '@thamel-threads/ky-auth-refresh requires `refreshAuthCall` to be a function that returns a promise.'\n    );\n  }\n\n  const cache: KyAuthRefreshCache = {\n    skipInstances: [],\n    refreshCall: undefined,\n    requestQueueInterceptorId: undefined,\n  };\n\n  // Merge options with defaults\n  const mergedOptions = mergeOptions(defaultOptions, options);\n\n  // Add afterResponse hook to handle authentication errors\n  const afterResponseHook = async (\n    request: Request,\n    requestOptions: any,\n    response: Response\n  ) => {\n    const hookOptions = mergeOptions(mergedOptions, requestOptions);\n\n    // Check if this request should skip auth refresh\n    if (requestOptions?.skipAuthRefresh) {\n      return response;\n    }\n\n    // Only handle error responses\n    if (response.ok) {\n      return response;\n    }\n\n    // Create a mock error object for compatibility with existing logic\n    const mockError = {\n      response: {\n        status: response.status,\n        request: request,\n      },\n      request: request,\n      options: requestOptions,\n    };\n\n    if (!shouldInterceptError(mockError, hookOptions, instance, cache)) {\n      return response;\n    }\n\n    if (hookOptions.pauseInstanceWhileRefreshing) {\n      cache.skipInstances.push(instance);\n    }\n\n    // If refresh call does not exist, create one\n    const refreshing = createRefreshCall(mockError, refreshAuthCall, cache);\n\n    // Create hook that will bind all the others requests until refreshAuthCall is resolved\n    createRequestQueueHook(instance, cache, hookOptions);\n\n    try {\n      await refreshing;\n      // Retry the failed request\n      const retryInstance = getRetryInstance(instance, hookOptions);\n      const retryResponse = await resendFailedRequest(mockError, retryInstance);\n      return retryResponse;\n    } catch {\n      // If refresh fails, return the original response\n      return response;\n    } finally {\n      unsetCache(instance, cache);\n    }\n  };\n\n  // Create a new ky instance with the afterResponse hook\n  return instance.extend({\n    hooks: {\n      afterResponse: [afterResponseHook],\n    },\n  });\n}\n\n// Default export for backward compatibility\nexport default createAuthRefreshHook;\n"]}